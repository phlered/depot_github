<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projet√© orthogonal sur un plan</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            color: rgba(255,255,255,0.9);
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
        }
        
        #canvas-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        canvas {
            display: block;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        canvas.moving-point {
            cursor: move !important;
        }
        
        canvas.moving-point:active {
            cursor: move !important;
        }
        
        .controls {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            max-width: 600px;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .value-display {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            color: #667eea;
            font-weight: bold;
        }
        
        .legend {
            background: rgba(255,255,255,0.95);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border-left: 4px solid #667eea;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        
        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid #ddd;
        }
        
        .formula {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #764ba2;
        }
    </style>
</head>
<body>
    <h1>Projet√© orthogonal d'un point sur un plan</h1>
    <p class="subtitle">Illustration interactive en 3D - Cliquez et d√©placez le point M rouge</p>
    
    <div id="canvas-container">
        <canvas id="canvas" width="700" height="500"></canvas>
    </div>
    
    <div class="controls">
        <div class="control-group">
            <label>Position X du point M: <span class="value-display" id="mx-value">0</span></label>
            <input type="range" id="mx" min="-3" max="3" step="0.1" value="0">
        </div>
        
        <div class="control-group">
            <label>Position Z du point M: <span class="value-display" id="mz-value">0</span></label>
            <input type="range" id="mz" min="-3" max="3" step="0.1" value="0">
        </div>
        
        <div class="control-group">
            <label>Hauteur du point M: <span class="value-display" id="my-value">2.5</span></label>
            <input type="range" id="my" min="0.5" max="4" step="0.1" value="2.5">
        </div>
        
        <div class="legend">
            <h3 style="margin-top: 0;">L√©gende</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(102, 126, 234, 0.5);"></div>
                <span>Plan ùí´</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e74c3c;"></div>
                <span>Point M (point initial)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #27ae60;"></div>
                <span>Point H (projet√© orthogonal de M sur ùí´)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f39c12; width: 30px; height: 3px;"></div>
                <span>Droite perpendiculaire (MH)</span>
            </div>
        </div>
        
        <div class="formula">
            <strong>D√©finition :</strong><br>
            Le projet√© orthogonal H du point M sur le plan ùí´ est l'intersection de ùí´ avec la droite perpendiculaire √† ùí´ passant par M.<br><br>
            <strong>Distance :</strong> d(M, ùí´) = MH
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Param√®tres de la sc√®ne
        let angleX = 0.4;
        let angleY = 0.6;
        let isDragging = false;
        let isMovingPoint = false;
        let lastX, lastY;
        
        // Position du point M
        let M = {x: 0, y: 2.5, z: 0};
        
        // Projection 3D vers 2D
        function project(x, y, z) {
            let x1 = x * Math.cos(angleY) - z * Math.sin(angleY);
            let z1 = x * Math.sin(angleY) + z * Math.cos(angleY);
            let y1 = y * Math.cos(angleX) - z1 * Math.sin(angleX);
            let z2 = y * Math.sin(angleX) + z1 * Math.cos(angleX);
            
            const scale = 80;
            const offsetX = canvas.width / 2;
            const offsetY = canvas.height / 2;
            
            return {
                x: offsetX + x1 * scale,
                y: offsetY - y1 * scale,
                z: z2
            };
        }
        
        // Dessiner un point
        function drawPoint(x, y, z, color, label, radius = 6) {
            const p = project(x, y, z);
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            if (label) {
                ctx.fillStyle = '#333';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(label, p.x + 12, p.y + 5);
            }
            
            return p;
        }
        
        // Dessiner une ligne
        function drawLine(x1, y1, z1, x2, y2, z2, color, width = 2, dashed = false) {
            const p1 = project(x1, y1, z1);
            const p2 = project(x2, y2, z2);
            
            ctx.beginPath();
            if (dashed) {
                ctx.setLineDash([5, 5]);
            } else {
                ctx.setLineDash([]);
            }
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Dessiner le plan
        function drawPlane() {
            const size = 3;
            const points = [
                project(-size, 0, -size),
                project(size, 0, -size),
                project(size, 0, size),
                project(-size, 0, size)
            ];
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(102, 126, 234, 0.5)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            for (let i = -size; i <= size; i += 0.5) {
                drawLine(i, 0, -size, i, 0, size, 'rgba(102, 126, 234, 0.2)', 1);
                drawLine(-size, 0, i, size, 0, i, 'rgba(102, 126, 234, 0.2)', 1);
            }
            
            const center = project(2.5, 0, 2.5);
            ctx.fillStyle = '#667eea';
            ctx.font = 'italic bold 18px Arial';
            ctx.fillText('ùí´', center.x, center.y);
        }
        
        // Dessiner l'angle droit
        function drawRightAngle(H, M, N, size = 0.3) {
            const HM = {x: M.x - H.x, y: M.y - H.y, z: M.z - H.z};
            const HN = {x: N.x - H.x, y: N.y - H.y, z: N.z - H.z};
            
            const lenHM = Math.sqrt(HM.x*HM.x + HM.y*HM.y + HM.z*HM.z);
            const lenHN = Math.sqrt(HN.x*HN.x + HN.y*HN.y + HN.z*HN.z);
            
            HM.x /= lenHM; HM.y /= lenHM; HM.z /= lenHM;
            HN.x /= lenHN; HN.y /= lenHN; HN.z /= lenHN;
            
            const p1 = {x: H.x + HM.x*size, y: H.y + HM.y*size, z: H.z + HM.z*size};
            const p2 = {x: p1.x + HN.x*size, y: p1.y + HN.y*size, z: p1.z + HN.z*size};
            const p3 = {x: H.x + HN.x*size, y: H.y + HN.y*size, z: H.z + HN.z*size};
            
            drawLine(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, '#333', 1.5);
            drawLine(p3.x, p3.y, p3.z, p2.x, p2.y, p2.z, '#333', 1.5);
        }
        
        // Fonction principale de dessin
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const H = {x: M.x, y: 0, z: M.z};
            const N = {x: M.x + 1.5, y: 0, z: M.z + 0.3};
            
            drawPlane();
            drawLine(M.x, M.y, M.z, H.x, H.y, H.z, '#f39c12', 3, true);
            drawLine(M.x, M.y, M.z, H.x, H.y, H.z, '#f39c12', 2);
            drawLine(H.x, H.y, H.z, N.x, N.y, N.z, '#3498db', 2);
            drawLine(M.x, M.y, M.z, N.x, N.y, N.z, '#95a5a6', 2);
            
            drawRightAngle(H, M, N);
            
            drawPoint(H.x, H.y, H.z, '#27ae60', 'H');
            drawPoint(M.x, M.y, M.z, '#e74c3c', 'M');
            drawPoint(N.x, N.y, N.z, '#3498db', 'N', 5);
            
            const distance = M.y.toFixed(2);
            const midPoint = project((M.x + H.x)/2, (M.y + H.y)/2, (M.z + H.z)/2);
            ctx.fillStyle = '#f39c12';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(`d = ${distance}`, midPoint.x + 10, midPoint.y);
        }
        
        // Contr√¥les
        const mxSlider = document.getElementById('mx');
        const mySlider = document.getElementById('my');
        const mzSlider = document.getElementById('mz');
        
        function updateSliders() {
            mxSlider.value = M.x;
            mySlider.value = M.y;
            mzSlider.value = M.z;
            document.getElementById('mx-value').textContent = M.x.toFixed(1);
            document.getElementById('my-value').textContent = M.y.toFixed(1);
            document.getElementById('mz-value').textContent = M.z.toFixed(1);
        }
        
        mxSlider.addEventListener('input', (e) => {
            M.x = parseFloat(e.target.value);
            updateSliders();
            draw();
        });
        
        mySlider.addEventListener('input', (e) => {
            M.y = parseFloat(e.target.value);
            updateSliders();
            draw();
        });
        
        mzSlider.addEventListener('input', (e) => {
            M.z = parseFloat(e.target.value);
            updateSliders();
            draw();
        });
        
        // V√©rifier si la souris est proche du point M
        function isNearPoint(mouseX, mouseY, pointX, pointY, pointZ, threshold = 20) {
            const p = project(pointX, pointY, pointZ);
            const distance = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
            return distance < threshold;
        }
        
        // Gestion de la souris
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (isNearPoint(mouseX, mouseY, M.x, M.y, M.z)) {
                isMovingPoint = true;
                canvas.classList.add('moving-point');
            } else {
                isDragging = true;
            }
            
            lastX = e.clientX;
            lastY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (!isDragging && !isMovingPoint) {
                if (isNearPoint(mouseX, mouseY, M.x, M.y, M.z)) {
                    canvas.style.cursor = 'move';
                } else {
                    canvas.style.cursor = 'grab';
                }
            }
            
            if (isMovingPoint) {
                const deltaX = (e.clientX - lastX) / 80;
                const deltaY = -(e.clientY - lastY) / 80;
                
                const cosY = Math.cos(angleY);
                const sinY = Math.sin(angleY);
                const cosX = Math.cos(angleX);
                
                M.x += deltaX * cosY;
                M.z += deltaX * sinY;
                M.y += deltaY * cosX;
                
                M.x = Math.max(-3, Math.min(3, M.x));
                M.y = Math.max(0.5, Math.min(4, M.y));
                M.z = Math.max(-3, Math.min(3, M.z));
                
                updateSliders();
                lastX = e.clientX;
                lastY = e.clientY;
                draw();
            } else if (isDragging) {
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;
                
                angleY += deltaX * 0.01;
                angleX += deltaY * 0.01;
                
                angleX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, angleX));
                
                lastX = e.clientX;
                lastY = e.clientY;
                
                draw();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            isMovingPoint = false;
            canvas.classList.remove('moving-point');
            canvas.style.cursor = 'grab';
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            isMovingPoint = false;
            canvas.classList.remove('moving-point');
            canvas.style.cursor = 'grab';
        });
        
        // Dessiner au chargement
        draw();
    </script>
</body>
</html>
